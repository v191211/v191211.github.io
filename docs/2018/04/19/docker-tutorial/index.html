<!DOCTYPE html> <!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"><![endif]--> <!--[if IE 7]><html class="no-js lt-ie9 lt-ie8"><![endif]--> <!--[if IE 8]><html class="no-js lt-ie9"><![endif]--> <!--[if gt IE 8]><!--> <html class="no-js" lang="zh"> <!--<![endif]--> <head> <meta charset="utf-8"> <!--[if IE]><meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'><![endif]--> <meta name="viewport" content="width=device-width,initial-scale=1"> <title>Docker 入门教程 | 晨霜’s Blog</title> <meta name="generator" content="Jekyll v3.9.0"/> <meta property="og:title" content="Docker 入门教程"/> <meta name="author" content="晨霜"/> <meta property="og:locale" content="zh"/> <meta name="description" content="一、环境配置的难题 二、虚拟机 三、Linux 容器 四、Docker 是什么？ 五、Docker 的用途 六、Docker 的安装 六、image 文件 七、实例：hello world 八、容器文件 九、Dockerfile 文件 十、实例：制作自己的 Docker 容器 10.1 编写 Dockerfile 文件 10.2 创建 image 文件 10.3 生成容器 10.4 CMD 命令 10.5 发布 image 文件 十一、其他有用的命令 2013年发布至今， Docker 一直广受瞩目，被认为可能会改变软件行业。 但是，许多人并不清楚 Docker 到底是什么，要解决什么问题，好处又在哪里？本文就来详细解释，帮助大家理解它，还带有简单易懂的实例，教你如何将它用于日常开发。 一、环境配置的难题 软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？ 用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。 如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：&quot;它在我的机器可以跑了&quot;（It works on my machine），言下之意就是，其他机器很可能跑不了。 环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。 二、虚拟机 虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。 虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。 （1）资源占用多 虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。 （2）冗余步骤多 虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。 （3）启动慢 启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。 三、Linux 容器 由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。 Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。 由于容器是进程级别的，相比虚拟机有很多优势。 （1）启动快 容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。 （2）资源占用少 容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。 （3）体积小 容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。 总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。 四、Docker 是什么？ Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。 Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。 总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。 五、Docker 的用途 Docker 的主要用途，目前有三大类。 （1）提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。 （2）提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。 （3）组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。 六、Docker 的安装 Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。下面的介绍都针对社区版。 Docker CE 的安装请参考官方文档。 Mac Windows Ubuntu Debian CentOS Fedora 其他 Linux 发行版 安装完成后，运行下面的命令，验证是否安装成功。 $ docker version # 或者 $ docker info Docker 需要用户具有 sudo 权限，为了避免每次命令都输入sudo，可以把用户加入 Docker 用户组（官方文档）。 $ sudo usermod -aG docker $USER Docker 是服务器—-客户端架构。命令行运行docker命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动（官方文档）。 # service 命令的用法 $ sudo service docker start # systemctl 命令的用法 $ sudo systemctl start docker 六、image 文件 Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。 image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。 # 列出本机的所有 image 文件。 $ docker image ls # 删除 image 文件 $ docker image rm [imageName] image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。 为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 Docker Hub 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。 七、实例：hello world 下面，我们通过最简单的 image 文件&quot;hello world&quot;，感受一下 Docker。 需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站，具体的修改方法在下一篇文章的第一节。有需要的朋友，可以先看一下。 首先，运行下面的命令，将 image 文件从仓库抓取到本地。 $ docker image pull library/hello-world 上面代码中，docker image pull 是抓取 image 文件的命令。library/hello-world 是 image 文件在仓库里面的位置，其中 library 是 image 文件所在的组，hello-world 是 image 文件的名字。 由于 Docker 官方提供的 image 文件，都放在 library 组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。 $ docker image pull hello-world 抓取成功以后，就可以在本机看到这个 image 文件了。 $ docker image ls 现在，运行这个 image 文件。 $ docker container run hello-world docker container run 命令会从 image 文件，生成一个正在运行的容器实例。 注意，docker container run 命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的 docker image pull 命令并不是必需的步骤。 如果运行成功，你会在屏幕上读到下面的输出。 $ docker container run hello-world Hello from Docker! This message shows that your installation appears to be working correctly. ... ... 输出这段提示以后，hello world 就会停止运行，容器自动终止。 有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。 $ docker container run -it ubuntu bash 对于那些不会自动终止的容器，必须使用docker container kill 命令手动终止。 $ docker container kill [containID] 八、容器文件 image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。 # 列出本机正在运行的容器 $ docker container ls # 列出本机所有容器，包括终止运行的容器 $ docker container ls --all 上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的 docker container kill 命令。 终止运行的容器文件，依然会占据硬盘空间，可以使用docker container rm 命令删除。 $ docker container rm [containerID] 运行上面的命令之后，再使用docker container ls –all 命令，就会发现被删除的容器文件已经消失了。 九、Dockerfile 文件 学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。 这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。 下面通过一个实例，演示如何编写 Dockerfile 文件。 十、实例：制作自己的 Docker 容器 下面我以 koa-demos 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。 作为准备工作，请先下载源码。 $ git clone https://github.com/ruanyf/koa-demos.git $ cd koa-demos 10.1 编写 Dockerfile 文件 首先，在项目的根目录下，新建一个文本文件 .dockerignore，写入下面的内容。 .git node_modules npm-debug.log 上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。 然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的内容。 FROM node:8.4 COPY . /app WORKDIR /app RUN npm install --registry=https://registry.npm.taobao.org EXPOSE 3000 上面代码一共五行，含义如下。 FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。 COPY . /app：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。 WORKDIR /app：指定接下来的工作路径为/app。 RUN npm install：在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。 EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。 10.2 创建 image 文件 有了 Dockerfile 文件以后，就可以使用 docker image build 命令创建 image 文件了。 $ docker image build -t koa-demo . # 或者 $ docker image build -t koa-demo:0.0.1 . 上面代码中，-t 参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是 latest。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。 如果运行成功，就可以看到新生成的 image 文件 koa-demo 了。 $ docker image ls 10.3 生成容器 docker container run 命令会从 image 文件生成容器。 $ docker container run -p 8000:3000 -it koa-demo /bin/bash # 或者 $ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash 上面命令的各个参数含义如下： -p参数：容器的 3000 端口映射到本机的 8000 端口。 -it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。 koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。 /bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。 如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。 root@66d80f4aaf1e:/app# 这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。 root@66d80f4aaf1e:/app# node demos/01.js 这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 http://127.0.0.1:8000，网页显示&quot;Not Found&quot;，这是因为这个 demo 没有写路由。 这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。 现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用 docker container kill 终止容器运行。 # 在本机的另一个终端窗口，查出容器的 ID $ docker container ls # 停止指定的容器运行 $ docker container kill [containerID] 容器停止运行之后，并不会消失，用下面的命令删除容器文件。 # 查出容器的 ID $ docker container ls --all # 删除指定的容器文件 $ docker container rm [containerID] 也可以使用 docker container run 命令的 –rm 参数，在容器终止运行后自动删除容器文件。 $ docker container run --rm -p 8000:3000 -it koa-demo /bin/bash 10.4 CMD 命令 上一节的例子里面，容器启动以后，需要手动输入命令 node demos/01.js。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。 FROM node:8.4 COPY . /app WORKDIR /app RUN npm install --registry=https://registry.npm.taobao.org EXPOSE 3000 CMD node demos/01.js 上面的 Dockerfile 里面，多了最后一行 CMD node demos/01.js，它表示容器启动后自动执行 node demos/01.js。 你可能会问，RUN 命令与 CMD 命令的区别在哪里？简单说，RUN 命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD 命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个 RUN 命令，但是只能有一个 CMD 命令。 注意，指定了 CMD 命令以后，docker container run 命令就不能附加命令了（比如前面的 /bin/bash），否则它会覆盖 CMD 命令。现在，启动容器可以使用下面的命令。 $ docker container run --rm -p 8000:3000 -it koa-demo:0.0.1 10.5 发布 image 文件 容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。 首先，去 hub.docker.com 或 cloud.docker.com 注册一个账户。然后，用下面的命令登录。 $ docker login 接着，为本地的 image 标注用户名和版本。 $ docker image tag [imageName] [username]/[repository]:[tag] # 实例 $ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1 也可以不标注用户名，重新构建一下 image 文件。 $ docker image build -t [username]/[repository]:[tag] . 最后，发布 image 文件。 $ docker image push [username]/[repository]:[tag] 发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。 十一、其他有用的命令 docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。 （1）docker container start 前面的 docker container run 命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用 docker container start 命令，它用来启动已经生成、已经停止运行的容器文件。 $ docker container start [containerID] （2）docker container stop 前面的 docker container kill 命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而 docker container stop 命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。 $ docker container stop [containerID] 这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。 （3）docker container logs docker container logs 命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果 docker run 命令运行容器的时候，没有使用 -it 参数，就要用这个命令查看输出。 $ docker container logs [containerID] （4）docker container exec docker container exec 命令用于进入一个正在运行的 docker 容器。如果 docker run 命令运行容器的时候，没有使用 -it 参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。 $ docker container exec -it [containerID] /bin/bash （5）docker container cp docker container cp 命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。 $ docker container cp [containID]:[/path/to/file] . 非常感谢你一直读到了这里，这个系列还有下一篇，介绍如何使用 Docker 搭建真正的网站，欢迎继续阅读。 原文：Docker 教程"/> <meta property="og:description" content="一、环境配置的难题 二、虚拟机 三、Linux 容器 四、Docker 是什么？ 五、Docker 的用途 六、Docker 的安装 六、image 文件 七、实例：hello world 八、容器文件 九、Dockerfile 文件 十、实例：制作自己的 Docker 容器 10.1 编写 Dockerfile 文件 10.2 创建 image 文件 10.3 生成容器 10.4 CMD 命令 10.5 发布 image 文件 十一、其他有用的命令 2013年发布至今， Docker 一直广受瞩目，被认为可能会改变软件行业。 但是，许多人并不清楚 Docker 到底是什么，要解决什么问题，好处又在哪里？本文就来详细解释，帮助大家理解它，还带有简单易懂的实例，教你如何将它用于日常开发。 一、环境配置的难题 软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？ 用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。 如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：&quot;它在我的机器可以跑了&quot;（It works on my machine），言下之意就是，其他机器很可能跑不了。 环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。 二、虚拟机 虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。 虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。 （1）资源占用多 虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。 （2）冗余步骤多 虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。 （3）启动慢 启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。 三、Linux 容器 由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。 Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。 由于容器是进程级别的，相比虚拟机有很多优势。 （1）启动快 容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。 （2）资源占用少 容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。 （3）体积小 容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。 总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。 四、Docker 是什么？ Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。 Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。 总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。 五、Docker 的用途 Docker 的主要用途，目前有三大类。 （1）提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。 （2）提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。 （3）组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。 六、Docker 的安装 Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。下面的介绍都针对社区版。 Docker CE 的安装请参考官方文档。 Mac Windows Ubuntu Debian CentOS Fedora 其他 Linux 发行版 安装完成后，运行下面的命令，验证是否安装成功。 $ docker version # 或者 $ docker info Docker 需要用户具有 sudo 权限，为了避免每次命令都输入sudo，可以把用户加入 Docker 用户组（官方文档）。 $ sudo usermod -aG docker $USER Docker 是服务器—-客户端架构。命令行运行docker命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动（官方文档）。 # service 命令的用法 $ sudo service docker start # systemctl 命令的用法 $ sudo systemctl start docker 六、image 文件 Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。 image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。 # 列出本机的所有 image 文件。 $ docker image ls # 删除 image 文件 $ docker image rm [imageName] image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。 为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 Docker Hub 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。 七、实例：hello world 下面，我们通过最简单的 image 文件&quot;hello world&quot;，感受一下 Docker。 需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站，具体的修改方法在下一篇文章的第一节。有需要的朋友，可以先看一下。 首先，运行下面的命令，将 image 文件从仓库抓取到本地。 $ docker image pull library/hello-world 上面代码中，docker image pull 是抓取 image 文件的命令。library/hello-world 是 image 文件在仓库里面的位置，其中 library 是 image 文件所在的组，hello-world 是 image 文件的名字。 由于 Docker 官方提供的 image 文件，都放在 library 组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。 $ docker image pull hello-world 抓取成功以后，就可以在本机看到这个 image 文件了。 $ docker image ls 现在，运行这个 image 文件。 $ docker container run hello-world docker container run 命令会从 image 文件，生成一个正在运行的容器实例。 注意，docker container run 命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的 docker image pull 命令并不是必需的步骤。 如果运行成功，你会在屏幕上读到下面的输出。 $ docker container run hello-world Hello from Docker! This message shows that your installation appears to be working correctly. ... ... 输出这段提示以后，hello world 就会停止运行，容器自动终止。 有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。 $ docker container run -it ubuntu bash 对于那些不会自动终止的容器，必须使用docker container kill 命令手动终止。 $ docker container kill [containID] 八、容器文件 image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。 # 列出本机正在运行的容器 $ docker container ls # 列出本机所有容器，包括终止运行的容器 $ docker container ls --all 上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的 docker container kill 命令。 终止运行的容器文件，依然会占据硬盘空间，可以使用docker container rm 命令删除。 $ docker container rm [containerID] 运行上面的命令之后，再使用docker container ls –all 命令，就会发现被删除的容器文件已经消失了。 九、Dockerfile 文件 学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。 这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。 下面通过一个实例，演示如何编写 Dockerfile 文件。 十、实例：制作自己的 Docker 容器 下面我以 koa-demos 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。 作为准备工作，请先下载源码。 $ git clone https://github.com/ruanyf/koa-demos.git $ cd koa-demos 10.1 编写 Dockerfile 文件 首先，在项目的根目录下，新建一个文本文件 .dockerignore，写入下面的内容。 .git node_modules npm-debug.log 上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。 然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的内容。 FROM node:8.4 COPY . /app WORKDIR /app RUN npm install --registry=https://registry.npm.taobao.org EXPOSE 3000 上面代码一共五行，含义如下。 FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。 COPY . /app：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。 WORKDIR /app：指定接下来的工作路径为/app。 RUN npm install：在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。 EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。 10.2 创建 image 文件 有了 Dockerfile 文件以后，就可以使用 docker image build 命令创建 image 文件了。 $ docker image build -t koa-demo . # 或者 $ docker image build -t koa-demo:0.0.1 . 上面代码中，-t 参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是 latest。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。 如果运行成功，就可以看到新生成的 image 文件 koa-demo 了。 $ docker image ls 10.3 生成容器 docker container run 命令会从 image 文件生成容器。 $ docker container run -p 8000:3000 -it koa-demo /bin/bash # 或者 $ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash 上面命令的各个参数含义如下： -p参数：容器的 3000 端口映射到本机的 8000 端口。 -it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。 koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。 /bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。 如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。 root@66d80f4aaf1e:/app# 这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。 root@66d80f4aaf1e:/app# node demos/01.js 这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 http://127.0.0.1:8000，网页显示&quot;Not Found&quot;，这是因为这个 demo 没有写路由。 这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。 现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用 docker container kill 终止容器运行。 # 在本机的另一个终端窗口，查出容器的 ID $ docker container ls # 停止指定的容器运行 $ docker container kill [containerID] 容器停止运行之后，并不会消失，用下面的命令删除容器文件。 # 查出容器的 ID $ docker container ls --all # 删除指定的容器文件 $ docker container rm [containerID] 也可以使用 docker container run 命令的 –rm 参数，在容器终止运行后自动删除容器文件。 $ docker container run --rm -p 8000:3000 -it koa-demo /bin/bash 10.4 CMD 命令 上一节的例子里面，容器启动以后，需要手动输入命令 node demos/01.js。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。 FROM node:8.4 COPY . /app WORKDIR /app RUN npm install --registry=https://registry.npm.taobao.org EXPOSE 3000 CMD node demos/01.js 上面的 Dockerfile 里面，多了最后一行 CMD node demos/01.js，它表示容器启动后自动执行 node demos/01.js。 你可能会问，RUN 命令与 CMD 命令的区别在哪里？简单说，RUN 命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD 命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个 RUN 命令，但是只能有一个 CMD 命令。 注意，指定了 CMD 命令以后，docker container run 命令就不能附加命令了（比如前面的 /bin/bash），否则它会覆盖 CMD 命令。现在，启动容器可以使用下面的命令。 $ docker container run --rm -p 8000:3000 -it koa-demo:0.0.1 10.5 发布 image 文件 容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。 首先，去 hub.docker.com 或 cloud.docker.com 注册一个账户。然后，用下面的命令登录。 $ docker login 接着，为本地的 image 标注用户名和版本。 $ docker image tag [imageName] [username]/[repository]:[tag] # 实例 $ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1 也可以不标注用户名，重新构建一下 image 文件。 $ docker image build -t [username]/[repository]:[tag] . 最后，发布 image 文件。 $ docker image push [username]/[repository]:[tag] 发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。 十一、其他有用的命令 docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。 （1）docker container start 前面的 docker container run 命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用 docker container start 命令，它用来启动已经生成、已经停止运行的容器文件。 $ docker container start [containerID] （2）docker container stop 前面的 docker container kill 命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而 docker container stop 命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。 $ docker container stop [containerID] 这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。 （3）docker container logs docker container logs 命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果 docker run 命令运行容器的时候，没有使用 -it 参数，就要用这个命令查看输出。 $ docker container logs [containerID] （4）docker container exec docker container exec 命令用于进入一个正在运行的 docker 容器。如果 docker run 命令运行容器的时候，没有使用 -it 参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。 $ docker container exec -it [containerID] /bin/bash （5）docker container cp docker container cp 命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。 $ docker container cp [containID]:[/path/to/file] . 非常感谢你一直读到了这里，这个系列还有下一篇，介绍如何使用 Docker 搭建真正的网站，欢迎继续阅读。 原文：Docker 教程"/> <link rel="canonical" href="https://empvalley.com/2018/04/19/docker-tutorial/"/> <meta property="og:url" content="https://empvalley.com/2018/04/19/docker-tutorial/"/> <meta property="og:site_name" content="晨霜’s Blog"/> <meta property="og:type" content="article"/> <meta property="article:published_time" content="2018-04-19T00:00:00+08:00"/> <meta name="twitter:card" content="summary"/> <meta property="twitter:title" content="Docker 入门教程"/> <script type="application/ld+json">
{"url":"https://empvalley.com/2018/04/19/docker-tutorial/","author":{"@type":"Person","name":"晨霜"},"description":"一、环境配置的难题 二、虚拟机 三、Linux 容器 四、Docker 是什么？ 五、Docker 的用途 六、Docker 的安装 六、image 文件 七、实例：hello world 八、容器文件 九、Dockerfile 文件 十、实例：制作自己的 Docker 容器 10.1 编写 Dockerfile 文件 10.2 创建 image 文件 10.3 生成容器 10.4 CMD 命令 10.5 发布 image 文件 十一、其他有用的命令 2013年发布至今， Docker 一直广受瞩目，被认为可能会改变软件行业。 但是，许多人并不清楚 Docker 到底是什么，要解决什么问题，好处又在哪里？本文就来详细解释，帮助大家理解它，还带有简单易懂的实例，教你如何将它用于日常开发。 一、环境配置的难题 软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？ 用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。 如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：&quot;它在我的机器可以跑了&quot;（It works on my machine），言下之意就是，其他机器很可能跑不了。 环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。 二、虚拟机 虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。 虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。 （1）资源占用多 虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。 （2）冗余步骤多 虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。 （3）启动慢 启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。 三、Linux 容器 由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。 Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。 由于容器是进程级别的，相比虚拟机有很多优势。 （1）启动快 容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。 （2）资源占用少 容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。 （3）体积小 容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。 总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。 四、Docker 是什么？ Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。 Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。 总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。 五、Docker 的用途 Docker 的主要用途，目前有三大类。 （1）提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。 （2）提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。 （3）组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。 六、Docker 的安装 Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。下面的介绍都针对社区版。 Docker CE 的安装请参考官方文档。 Mac Windows Ubuntu Debian CentOS Fedora 其他 Linux 发行版 安装完成后，运行下面的命令，验证是否安装成功。 $ docker version # 或者 $ docker info Docker 需要用户具有 sudo 权限，为了避免每次命令都输入sudo，可以把用户加入 Docker 用户组（官方文档）。 $ sudo usermod -aG docker $USER Docker 是服务器—-客户端架构。命令行运行docker命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动（官方文档）。 # service 命令的用法 $ sudo service docker start # systemctl 命令的用法 $ sudo systemctl start docker 六、image 文件 Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。 image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。 # 列出本机的所有 image 文件。 $ docker image ls # 删除 image 文件 $ docker image rm [imageName] image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。 为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 Docker Hub 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。 七、实例：hello world 下面，我们通过最简单的 image 文件&quot;hello world&quot;，感受一下 Docker。 需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站，具体的修改方法在下一篇文章的第一节。有需要的朋友，可以先看一下。 首先，运行下面的命令，将 image 文件从仓库抓取到本地。 $ docker image pull library/hello-world 上面代码中，docker image pull 是抓取 image 文件的命令。library/hello-world 是 image 文件在仓库里面的位置，其中 library 是 image 文件所在的组，hello-world 是 image 文件的名字。 由于 Docker 官方提供的 image 文件，都放在 library 组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。 $ docker image pull hello-world 抓取成功以后，就可以在本机看到这个 image 文件了。 $ docker image ls 现在，运行这个 image 文件。 $ docker container run hello-world docker container run 命令会从 image 文件，生成一个正在运行的容器实例。 注意，docker container run 命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的 docker image pull 命令并不是必需的步骤。 如果运行成功，你会在屏幕上读到下面的输出。 $ docker container run hello-world Hello from Docker! This message shows that your installation appears to be working correctly. ... ... 输出这段提示以后，hello world 就会停止运行，容器自动终止。 有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。 $ docker container run -it ubuntu bash 对于那些不会自动终止的容器，必须使用docker container kill 命令手动终止。 $ docker container kill [containID] 八、容器文件 image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。 # 列出本机正在运行的容器 $ docker container ls # 列出本机所有容器，包括终止运行的容器 $ docker container ls --all 上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的 docker container kill 命令。 终止运行的容器文件，依然会占据硬盘空间，可以使用docker container rm 命令删除。 $ docker container rm [containerID] 运行上面的命令之后，再使用docker container ls –all 命令，就会发现被删除的容器文件已经消失了。 九、Dockerfile 文件 学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。 这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。 下面通过一个实例，演示如何编写 Dockerfile 文件。 十、实例：制作自己的 Docker 容器 下面我以 koa-demos 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。 作为准备工作，请先下载源码。 $ git clone https://github.com/ruanyf/koa-demos.git $ cd koa-demos 10.1 编写 Dockerfile 文件 首先，在项目的根目录下，新建一个文本文件 .dockerignore，写入下面的内容。 .git node_modules npm-debug.log 上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。 然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的内容。 FROM node:8.4 COPY . /app WORKDIR /app RUN npm install --registry=https://registry.npm.taobao.org EXPOSE 3000 上面代码一共五行，含义如下。 FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。 COPY . /app：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。 WORKDIR /app：指定接下来的工作路径为/app。 RUN npm install：在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。 EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。 10.2 创建 image 文件 有了 Dockerfile 文件以后，就可以使用 docker image build 命令创建 image 文件了。 $ docker image build -t koa-demo . # 或者 $ docker image build -t koa-demo:0.0.1 . 上面代码中，-t 参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是 latest。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。 如果运行成功，就可以看到新生成的 image 文件 koa-demo 了。 $ docker image ls 10.3 生成容器 docker container run 命令会从 image 文件生成容器。 $ docker container run -p 8000:3000 -it koa-demo /bin/bash # 或者 $ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash 上面命令的各个参数含义如下： -p参数：容器的 3000 端口映射到本机的 8000 端口。 -it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。 koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。 /bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。 如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。 root@66d80f4aaf1e:/app# 这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。 root@66d80f4aaf1e:/app# node demos/01.js 这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 http://127.0.0.1:8000，网页显示&quot;Not Found&quot;，这是因为这个 demo 没有写路由。 这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。 现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用 docker container kill 终止容器运行。 # 在本机的另一个终端窗口，查出容器的 ID $ docker container ls # 停止指定的容器运行 $ docker container kill [containerID] 容器停止运行之后，并不会消失，用下面的命令删除容器文件。 # 查出容器的 ID $ docker container ls --all # 删除指定的容器文件 $ docker container rm [containerID] 也可以使用 docker container run 命令的 –rm 参数，在容器终止运行后自动删除容器文件。 $ docker container run --rm -p 8000:3000 -it koa-demo /bin/bash 10.4 CMD 命令 上一节的例子里面，容器启动以后，需要手动输入命令 node demos/01.js。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。 FROM node:8.4 COPY . /app WORKDIR /app RUN npm install --registry=https://registry.npm.taobao.org EXPOSE 3000 CMD node demos/01.js 上面的 Dockerfile 里面，多了最后一行 CMD node demos/01.js，它表示容器启动后自动执行 node demos/01.js。 你可能会问，RUN 命令与 CMD 命令的区别在哪里？简单说，RUN 命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD 命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个 RUN 命令，但是只能有一个 CMD 命令。 注意，指定了 CMD 命令以后，docker container run 命令就不能附加命令了（比如前面的 /bin/bash），否则它会覆盖 CMD 命令。现在，启动容器可以使用下面的命令。 $ docker container run --rm -p 8000:3000 -it koa-demo:0.0.1 10.5 发布 image 文件 容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。 首先，去 hub.docker.com 或 cloud.docker.com 注册一个账户。然后，用下面的命令登录。 $ docker login 接着，为本地的 image 标注用户名和版本。 $ docker image tag [imageName] [username]/[repository]:[tag] # 实例 $ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1 也可以不标注用户名，重新构建一下 image 文件。 $ docker image build -t [username]/[repository]:[tag] . 最后，发布 image 文件。 $ docker image push [username]/[repository]:[tag] 发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。 十一、其他有用的命令 docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。 （1）docker container start 前面的 docker container run 命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用 docker container start 命令，它用来启动已经生成、已经停止运行的容器文件。 $ docker container start [containerID] （2）docker container stop 前面的 docker container kill 命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而 docker container stop 命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。 $ docker container stop [containerID] 这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。 （3）docker container logs docker container logs 命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果 docker run 命令运行容器的时候，没有使用 -it 参数，就要用这个命令查看输出。 $ docker container logs [containerID] （4）docker container exec docker container exec 命令用于进入一个正在运行的 docker 容器。如果 docker run 命令运行容器的时候，没有使用 -it 参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。 $ docker container exec -it [containerID] /bin/bash （5）docker container cp docker container cp 命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。 $ docker container cp [containID]:[/path/to/file] . 非常感谢你一直读到了这里，这个系列还有下一篇，介绍如何使用 Docker 搭建真正的网站，欢迎继续阅读。 原文：Docker 教程","@type":"BlogPosting","headline":"Docker 入门教程","dateModified":"2018-04-19T00:00:00+08:00","datePublished":"2018-04-19T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://empvalley.com/2018/04/19/docker-tutorial/"},"@context":"https://schema.org"}</script> <meta name="keywords" content="Docker"/> <link type="application/atom+xml" rel="alternate" href="https://empvalley.com/feed.xml" title="晨霜’s Blog"/> <link href='/assets/stylesheets/blog.css' rel="stylesheet" type="text/css"> <script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.min.js"></script> <script>window.Modernizr||document.write('<script src="/assets/javascripts/modernizr-2.8.3.min.js"><\/script>');</script> <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script> <script>window.jQuery||document.write('<script src="/assets/javascripts/jquery-3.3.1.min.js"><\/script>');</script> <script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script> <script>window.Pace||document.write('<script src="/assets/javascripts/pace.min.js"><\/script>');</script> <script>(function(b,m,h,a,g){b[a]=b[a]||[];b[a].push({"gtm.start":new Date().getTime(),event:"gtm.js"});var k=m.getElementsByTagName(h)[0],e=m.createElement(h),c=a!="dataLayer"?"&l="+a:"";e.async=true;e.src="https://www.googletagmanager.com/gtm.js?id="+g+c;k.parentNode.insertBefore(e,k)})(window,document,"script","dataLayer","GTM-WLHQF68");</script> </head> <body> <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WLHQF68" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript> <!--[if IE]><p class="site-notice">您正在使用一个过时的网页浏览器。请<a href="http://browsehappy.com/" target="_blank">升级您的浏览器</a>或<a href="http://www.google.com/chromeframe/?redirect=true" target="_blank">开启 Google Chrome Frame</a> 来提高用户体验。</p><![endif]--> <noscript> <p class="site-notice">本网站需要 JavaScript。请查阅指南来<a href="http://www.enable-javascript.com/" target="_blank">给您的浏览器开启 JavaScript 功能</a>。</p> </noscript> <div class="nav-wrapper overlay-wrapper"> <div class="nav-form overlay-form"> <span class="overlay-header menu">菜单</span> <a class="btn-close">关闭</a> <div class="results"> <ul> <li><a href="/blog/categories/">文章分类</a></li> <li><a href="/blog/tags/">文章标签</a></li> <li><a href="/">关于</a></li> </ul> </div> </div> </div> <div class="search-wrapper overlay-wrapper"> <div class="search-form overlay-form"> <input type="text" class="overlay-header search-field" placeholder="搜索..."> <a class="btn-close">关闭</a> <ul class="results"></ul> </div> </div> <div id="page" class="hentry"> <header class="the-header"> <div class="unit-head"> <div class="unit-inner unit-head-inner"> <nav class="nav-global"> <ul> <li class="logo nav-link"> <button class="btn-menu" title="菜单"></button> <a href="/blog/">晨霜’s Blog</a> <!--[if !IE]>--> <button class="btn-search" title="搜索"></button> <!--<![endif]--> </li> <li class="nav-link"><a title="文章分类" href="/blog/categories/">文章分类</a></li> <li class="nav-link"><a title="文章标签" href="/blog/tags/">文章标签</a></li> <!--[if !IE]>--> <li class="nav-link"><a title="搜索" class="btn-search" href="#">搜索</a></li> <!--<![endif]--> </ul> </nav> </div> </div> </header> <div class="body animated fadeInDown" role="main"> <div class="unit-body"> <div class="unit-inner unit-body-inner"> <div class="entry-content"> <article class="unit-article layout-post"> <div class="unit-inner unit-article-inner"> <div itemscope itemtype="http://schema.org/Article" class="content"> <header> <div class="unit-head"> <div class="unit-inner unit-head-inner"> <h1 class="entry-title" itemprop="name">Docker 入门教程</h1> </div> </div> </header> <div class="bd article-content"> <div class="entry-content"> <div class="meta"> <p class="date-publish"> 发表信息: <time itemprop="datePublished" class="date-pub updated" title="2018-04-19T00:00:00+08:00" datetime="2018-04-19T00:00:00+08:00">April 19, 2018 </time> by <a class="author" href="/" rel="author" title="显示作者"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"> <span itemprop="name">晨霜</span> </span> </a> <a class="license-icon" rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" title="显示许可证"> <img alt="Creative Commons Licence" style="border-width:0" src="/assets/images/theme/cc-by-sa.png" height="16" width="80"/> </a> </p> <ul class="list-category list-linear"> <li class="list-head">文章分类: </li> <li> <a href="/blog/categories/#技术" title="技术"> 技术 <span>39</span></a> </li> </ul> <ul class="list-tag list-linear"> <li class="list-head">文章标签: </li> <li> <a href="/blog/tags/#Docker" title="Docker">Docker <span>1</span></a> </li> </ul> </div> <div itemprop="articleBody"> <ul class="toc" id="markdown-toc"> <li><a href="#heading-一环境配置的难题" id="markdown-toc-heading-一环境配置的难题">一、环境配置的难题</a></li> <li><a href="#heading-二虚拟机" id="markdown-toc-heading-二虚拟机">二、虚拟机</a></li> <li><a href="#heading-三linux-容器" id="markdown-toc-heading-三linux-容器">三、Linux 容器</a></li> <li><a href="#heading-四docker-是什么" id="markdown-toc-heading-四docker-是什么">四、Docker 是什么？</a></li> <li><a href="#heading-五docker-的用途" id="markdown-toc-heading-五docker-的用途">五、Docker 的用途</a></li> <li><a href="#heading-六docker-的安装" id="markdown-toc-heading-六docker-的安装">六、Docker 的安装</a></li> <li><a href="#heading-六image-文件" id="markdown-toc-heading-六image-文件">六、image 文件</a></li> <li><a href="#heading-七实例hello-world" id="markdown-toc-heading-七实例hello-world">七、实例：hello world</a></li> <li><a href="#heading-八容器文件" id="markdown-toc-heading-八容器文件">八、容器文件</a></li> <li><a href="#heading-九dockerfile-文件" id="markdown-toc-heading-九dockerfile-文件">九、Dockerfile 文件</a></li> <li><a href="#heading-十实例制作自己的-docker-容器" id="markdown-toc-heading-十实例制作自己的-docker-容器">十、实例：制作自己的 Docker 容器</a> <ul> <li><a href="#heading-101-编写-dockerfile-文件" id="markdown-toc-heading-101-编写-dockerfile-文件">10.1 编写 Dockerfile 文件</a></li> <li><a href="#heading-102-创建-image-文件" id="markdown-toc-heading-102-创建-image-文件">10.2 创建 image 文件</a></li> <li><a href="#heading-103-生成容器" id="markdown-toc-heading-103-生成容器">10.3 生成容器</a></li> <li><a href="#heading-104-cmd-命令" id="markdown-toc-heading-104-cmd-命令">10.4 CMD 命令</a></li> <li><a href="#heading-105-发布-image-文件" id="markdown-toc-heading-105-发布-image-文件">10.5 发布 image 文件</a></li> </ul> </li> <li><a href="#heading-十一其他有用的命令" id="markdown-toc-heading-十一其他有用的命令">十一、其他有用的命令</a></li> </ul> <p>2013年发布至今， Docker 一直广受瞩目，被认为可能会改变软件行业。</p> <p>但是，许多人并不清楚 Docker 到底是什么，要解决什么问题，好处又在哪里？本文就来详细解释，帮助大家理解它，还带有简单易懂的实例，教你如何将它用于日常开发。</p> <p><img src="https://empvalley.com/assets/images/posts/bg2018020901.png" alt=""/></p> <h2 id="heading-一环境配置的难题">一、环境配置的难题</h2> <p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p> <p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p> <p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说："它在我的机器可以跑了"（It works on my machine），言下之意就是，其他机器很可能跑不了。</p> <p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p> <h2 id="heading-二虚拟机">二、虚拟机</h2> <p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p> <p>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。</p> <p>（1）资源占用多</p> <p>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p> <p>（2）冗余步骤多</p> <p>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p> <p>（3）启动慢</p> <p>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p> <h2 id="heading-三linux-容器">三、Linux 容器</h2> <p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p> <p>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p> <p>由于容器是进程级别的，相比虚拟机有很多优势。</p> <p>（1）启动快</p> <p>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p> <p>（2）资源占用少</p> <p>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p> <p>（3）体积小</p> <p>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</p> <p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p> <h2 id="heading-四docker-是什么">四、Docker 是什么？</h2> <p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</p> <p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p> <p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p> <h2 id="heading-五docker-的用途">五、Docker 的用途</h2> <p>Docker 的主要用途，目前有三大类。</p> <p><strong>（1）提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p> <p><strong>（2）提供弹性的云服务。</strong>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p> <p><strong>（3）组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p> <h2 id="heading-六docker-的安装">六、Docker 的安装</h2> <p>Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。下面的介绍都针对社区版。</p> <p>Docker CE 的安装请参考官方文档。</p> <blockquote> <p><a href="https://docs.docker.com/docker-for-mac/install/">Mac</a> <a href="https://docs.docker.com/docker-for-windows/install/">Windows</a> <a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Ubuntu</a> <a href="https://docs.docker.com/install/linux/docker-ce/debian/">Debian</a> <a href="https://docs.docker.com/install/linux/docker-ce/centos/">CentOS</a> <a href="https://docs.docker.com/install/linux/docker-ce/fedora/">Fedora</a> <a href="https://docs.docker.com/install/linux/docker-ce/binaries/">其他 Linux 发行版</a></p> </blockquote> <p>安装完成后，运行下面的命令，验证是否安装成功。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker version
<span class="c"># 或者</span>
<span class="nv">$ </span>docker info
</code></pre></div></div> <p>Docker 需要用户具有 sudo 权限，为了避免每次命令都输入<strong>sudo</strong>，可以把用户加入 Docker 用户组（<a href="https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user">官方文档</a>）。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>usermod <span class="nt">-aG</span> docker <span class="nv">$USER</span>
</code></pre></div></div> <p>Docker 是服务器—-客户端架构。命令行运行docker命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动（<a href="https://docs.docker.com/config/daemon/systemd/">官方文档</a>）。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># service 命令的用法</span>
<span class="nv">$ </span><span class="nb">sudo </span>service docker start

<span class="c"># systemctl 命令的用法</span>
<span class="nv">$ </span><span class="nb">sudo </span>systemctl start docker
</code></pre></div></div> <h2 id="heading-六image-文件">六、image 文件</h2> <p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p> <p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 列出本机的所有 image 文件。</span>
<span class="nv">$ </span>docker image <span class="nb">ls</span>

<span class="c"># 删除 image 文件</span>
<span class="nv">$ </span>docker image <span class="nb">rm</span> <span class="o">[</span>imageName]
</code></pre></div></div> <p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p> <p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/">Docker Hub</a> 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p> <h2 id="heading-七实例hello-world">七、实例：hello world</h2> <p>下面，我们通过最简单的 image 文件"<a href="https://hub.docker.com/r/library/hello-world/">hello world</a>"，感受一下 Docker。</p> <p>需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站，具体的修改方法在下一篇文章的第一节。有需要的朋友，可以先看一下。</p> <p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker image pull library/hello-world
</code></pre></div></div> <p>上面代码中，<strong>docker image pull</strong> 是抓取 image 文件的命令。<strong>library/hello-world</strong> 是 image 文件在仓库里面的位置，其中 <strong>library</strong> 是 image 文件所在的组，<strong>hello-world</strong> 是 image 文件的名字。</p> <p>由于 Docker 官方提供的 image 文件，都放在 <strong><a href="https://hub.docker.com/r/library/">library</a></strong> 组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker image pull hello-world
</code></pre></div></div> <p>抓取成功以后，就可以在本机看到这个 image 文件了。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker image <span class="nb">ls</span>
</code></pre></div></div> <p>现在，运行这个 image 文件。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker container run hello-world
</code></pre></div></div> <p><strong>docker container run</strong> 命令会从 image 文件，生成一个正在运行的容器实例。</p> <p>注意，<strong>docker container run</strong> 命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的 <strong>docker image pull</strong> 命令并不是必需的步骤。</p> <p>如果运行成功，你会在屏幕上读到下面的输出。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker container run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.

... ...
</code></pre></div></div> <p>输出这段提示以后，<strong>hello world</strong> 就会停止运行，容器自动终止。</p> <p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker container run <span class="nt">-it</span> ubuntu bash
</code></pre></div></div> <p>对于那些不会自动终止的容器，必须使用<strong>docker container kill</strong> 命令手动终止。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker container <span class="nb">kill</span> <span class="o">[</span>containID]
</code></pre></div></div> <h2 id="heading-八容器文件">八、容器文件</h2> <p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong>也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 列出本机正在运行的容器</span>
<span class="nv">$ </span>docker container <span class="nb">ls</span>

<span class="c"># 列出本机所有容器，包括终止运行的容器</span>
<span class="nv">$ </span>docker container <span class="nb">ls</span> <span class="nt">--all</span>
</code></pre></div></div> <p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的 <strong>docker container kill</strong> 命令。</p> <p>终止运行的容器文件，依然会占据硬盘空间，可以使用<strong>docker container rm</strong> 命令删除。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker container <span class="nb">rm</span> <span class="o">[</span>containerID]
</code></pre></div></div> <p>运行上面的命令之后，再使用<strong>docker container ls –all</strong> 命令，就会发现被删除的容器文件已经消失了。</p> <h2 id="heading-九dockerfile-文件">九、Dockerfile 文件</h2> <p>学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。</p> <p>这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p> <p>下面通过一个实例，演示如何编写 Dockerfile 文件。</p> <h2 id="heading-十实例制作自己的-docker-容器">十、实例：制作自己的 Docker 容器</h2> <p>下面我以 <a href="https://www.ruanyifeng.com/blog/2017/08/koa.html">koa-demos</a> 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。</p> <p>作为准备工作，请先<a href="https://github.com/ruanyf/koa-demos/archive/master.zip">下载源码</a>。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git clone https://github.com/ruanyf/koa-demos.git
<span class="nv">$ </span><span class="nb">cd </span>koa-demos
</code></pre></div></div> <h3 id="heading-101-编写-dockerfile-文件">10.1 编写 Dockerfile 文件</h3> <p>首先，在项目的根目录下，新建一个文本文件 <strong>.dockerignore</strong>，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/.dockerignore">内容</a>。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.git
node_modules
npm-debug.log
</code></pre></div></div> <p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p> <p>然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/Dockerfile">内容</a>。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM node:8.4
COPY <span class="nb">.</span> /app
WORKDIR /app
RUN npm <span class="nb">install</span> <span class="nt">--registry</span><span class="o">=</span>https://registry.npm.taobao.org
EXPOSE 3000
</code></pre></div></div> <p>上面代码一共五行，含义如下。</p> <blockquote> <ul> <li>FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。</li> <li>COPY . /app：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。</li> <li>WORKDIR /app：指定接下来的工作路径为/app。</li> <li>RUN npm install：在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li> <li>EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li> </ul> </blockquote> <h3 id="heading-102-创建-image-文件">10.2 创建 image 文件</h3> <p>有了 Dockerfile 文件以后，就可以使用 <strong>docker image build</strong> 命令创建 image 文件了。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker image build <span class="nt">-t</span> koa-demo <span class="nb">.</span>
<span class="c"># 或者</span>
<span class="nv">$ </span>docker image build <span class="nt">-t</span> koa-demo:0.0.1 <span class="nb">.</span>
</code></pre></div></div> <p>上面代码中，<strong>-t</strong> 参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是 <strong>latest</strong>。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</p> <p>如果运行成功，就可以看到新生成的 image 文件 <strong>koa-demo</strong> 了。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker image <span class="nb">ls</span>
</code></pre></div></div> <h3 id="heading-103-生成容器">10.3 生成容器</h3> <p><strong>docker container run</strong> 命令会从 image 文件生成容器。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker container run <span class="nt">-p</span> 8000:3000 <span class="nt">-it</span> koa-demo /bin/bash
<span class="c"># 或者</span>
<span class="nv">$ </span>docker container run <span class="nt">-p</span> 8000:3000 <span class="nt">-it</span> koa-demo:0.0.1 /bin/bash
</code></pre></div></div> <p>上面命令的各个参数含义如下：</p> <blockquote> <ul> <li><code class="language-plaintext highlighter-rouge">-p</code>参数：容器的 3000 端口映射到本机的 8000 端口。</li> <li><code class="language-plaintext highlighter-rouge">-it</code>参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li> <li><code class="language-plaintext highlighter-rouge">koa-demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li> <li><code class="language-plaintext highlighter-rouge">/bin/bash</code>：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li> </ul> </blockquote> <p>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@66d80f4aaf1e:/app#
</code></pre></div></div> <p>这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@66d80f4aaf1e:/app# node demos/01.js
</code></pre></div></div> <p>这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 http://127.0.0.1:8000，网页显示"Not Found"，这是因为这个 <a href="https://github.com/ruanyf/koa-demos/blob/master/demos/01.js">demo</a> 没有写路由。</p> <p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。</p> <p>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用 <strong>docker container kill</strong> 终止容器运行。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 在本机的另一个终端窗口，查出容器的 ID</span>
<span class="nv">$ </span>docker container <span class="nb">ls</span>

<span class="c"># 停止指定的容器运行</span>
<span class="nv">$ </span>docker container <span class="nb">kill</span> <span class="o">[</span>containerID]
</code></pre></div></div> <p>容器停止运行之后，并不会消失，用下面的命令删除容器文件。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查出容器的 ID</span>
<span class="nv">$ </span>docker container <span class="nb">ls</span> <span class="nt">--all</span>

<span class="c"># 删除指定的容器文件</span>
<span class="nv">$ </span>docker container <span class="nb">rm</span> <span class="o">[</span>containerID]
</code></pre></div></div> <p>也可以使用 <strong>docker container run</strong> 命令的 <strong>–rm</strong> 参数，在容器终止运行后自动删除容器文件。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker container run <span class="nt">--rm</span> <span class="nt">-p</span> 8000:3000 <span class="nt">-it</span> koa-demo /bin/bash
</code></pre></div></div> <h3 id="heading-104-cmd-命令">10.4 CMD 命令</h3> <p>上一节的例子里面，容器启动以后，需要手动输入命令 <strong>node demos/01.js</strong>。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM node:8.4
COPY <span class="nb">.</span> /app
WORKDIR /app
RUN npm <span class="nb">install</span> <span class="nt">--registry</span><span class="o">=</span>https://registry.npm.taobao.org
EXPOSE 3000
CMD node demos/01.js
</code></pre></div></div> <p>上面的 Dockerfile 里面，多了最后一行 <strong>CMD node demos/01.js</strong>，它表示容器启动后自动执行 <strong>node demos/01.js</strong>。</p> <p>你可能会问，<strong>RUN</strong> 命令与 <strong>CMD</strong> 命令的区别在哪里？简单说，<strong>RUN</strong> 命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；<strong>CMD</strong> 命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个 <strong>RUN</strong> 命令，但是只能有一个 <strong>CMD</strong> 命令。</p> <p>注意，指定了 <strong>CMD</strong> 命令以后，<strong>docker container run</strong> 命令就不能附加命令了（比如前面的 <strong>/bin/bash</strong>），否则它会覆盖 <strong>CMD</strong> 命令。现在，启动容器可以使用下面的命令。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker container run <span class="nt">--rm</span> <span class="nt">-p</span> 8000:3000 <span class="nt">-it</span> koa-demo:0.0.1
</code></pre></div></div> <h3 id="heading-105-发布-image-文件">10.5 发布 image 文件</h3> <p>容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。</p> <p>首先，去 <a href="https://hub.docker.com/">hub.docker.com</a> 或 <a href="https://cloud.docker.com/">cloud.docker.com</a> 注册一个账户。然后，用下面的命令登录。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker login
</code></pre></div></div> <p>接着，为本地的 image 标注用户名和版本。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker image tag <span class="o">[</span>imageName] <span class="o">[</span>username]/[repository]:[tag]
<span class="c"># 实例</span>
<span class="nv">$ </span>docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1
</code></pre></div></div> <p>也可以不标注用户名，重新构建一下 image 文件。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker image build <span class="nt">-t</span> <span class="o">[</span>username]/[repository]:[tag] <span class="nb">.</span>
</code></pre></div></div> <p>最后，发布 image 文件。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker image push <span class="o">[</span>username]/[repository]:[tag]
</code></pre></div></div> <p>发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。</p> <h2 id="heading-十一其他有用的命令">十一、其他有用的命令</h2> <p>docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。</p> <p><strong>（1）docker container start</strong></p> <p>前面的 <strong>docker container run</strong> 命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用 <strong>docker container start</strong> 命令，它用来启动已经生成、已经停止运行的容器文件。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker container start <span class="o">[</span>containerID]
</code></pre></div></div> <p><strong>（2）docker container stop</strong></p> <p>前面的 <strong>docker container kill</strong> 命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而 <strong>docker container stop</strong> 命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker container stop <span class="o">[</span>containerID]
</code></pre></div></div> <p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p> <p><strong>（3）docker container logs</strong></p> <p><strong>docker container logs</strong> 命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果 <strong>docker run</strong> 命令运行容器的时候，没有使用 <strong>-it</strong> 参数，就要用这个命令查看输出。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker container logs <span class="o">[</span>containerID]
</code></pre></div></div> <p><strong>（4）docker container exec</strong></p> <p><strong>docker container exec</strong> 命令用于进入一个正在运行的 docker 容器。如果 <strong>docker run</strong> 命令运行容器的时候，没有使用 <strong>-it</strong> 参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker container <span class="nb">exec</span> <span class="nt">-it</span> <span class="o">[</span>containerID] /bin/bash
</code></pre></div></div> <p><strong>（5）docker container cp</strong></p> <p><strong>docker container cp</strong> 命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker container <span class="nb">cp</span> <span class="o">[</span>containID]:[/path/to/file] <span class="nb">.</span>
</code></pre></div></div> <p>非常感谢你一直读到了这里，这个系列还有<a href="https://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html">下一篇</a>，介绍如何使用 Docker 搭建真正的网站，欢迎<a href="https://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html">继续阅读</a>。</p> <hr/> <p>原文：<a href="http://www.runoob.com/docker/docker-tutorial.html">Docker 教程</a></p> </div> </div> </div> <footer class="unit-foot"> <div class="unit-inner unit-foot-inner"> <div class="post-buttons"> <a class="internal gotop" href="#page" title="返回顶部">返回顶部</a> <div class="addthis_toolbox addthis_default_style addthis_32x32_style"> <small class="label">分享本文：</small> <a class="btn-share-post addthis_button_email"></a> <a class="btn-share-post addthis_button_facebook"></a> <a class="btn-share-post addthis_button_google_plusone_share"></a> <a class="btn-share-post addthis_button_reddit"></a> <a class="btn-share-post addthis_button_twitter"></a> </div> <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5fd67ed699f02738"></script> </div> <nav class="pagination"> <a class="internal" rel="prev" href="/2018/03/25/sushu/" title="上一篇 '素书'"> ← 素书</a> <a class="internal" rel="next" href="/2018/04/19/install-centos-on-virtualbox/" title="下一篇 '配置安装在 Virtual box 中的 CentOS'">配置安装在 Virtual box 中的 CentOS → </a> </nav> </div> </footer> <div class="misc-content"> <script>$(document).ready(function(){var b="CefuUqy9qWjTPQyiiLRTCFkFAOl7FIXLjBHyIdpFqMFDFYgqYgOHvaJIZXybCUV4";var c="fighting-v";var a="link:"+$(".comments .show-hidden").attr("data-disqus-url");$.ajax({type:"GET",url:"//disqus.com/api/3.0/threads/set.jsonp",data:{api_key:b,forum:c,thread:a},cache:false,dataType:"jsonp",success:function(d){if(d.response.length===1){btnText="显示评论 ("+d.response[0].posts+")";$(".comments .show-hidden").html(btnText)}}});$(".comments .show-hidden").on("click",function(){$.ajaxSetup({cache:true});$.getScript("//"+c+".disqus.com/embed.js");$.ajaxSetup({cache:false});$(this).remove()});if(/\#comments/.test(location.hash)){$(".comments .show-hidden").trigger("click")}});</script> <div class="comments"> <button class="center-block show-hidden" title="显示评论" data-disqus-url="https://empvalley.com/2018/04/19/docker-tutorial/">显示评论</button> <div id="disqus_thread"></div> </div> </div> </div> </div> </article> </div> </div> </div> </div> <footer class="the-footer"> <div class="unit-foot"> <div class="unit-inner unit-foot-inner"> <div class="misc vcard"> <div class="about"> <h4><a href="/">关于</a></h4> <p>晨霜，软件开发，深圳</p> <p><small>本博客主题 <a href="https://github.com/yizeng/jekyll-theme-simple-texture" target="_blank">Simple Texture</a> 由 <a href="http://yizeng.me" target="_blank">Yi Zeng</a> 基于 <a href="https://jekyllrb.com/" target="_blank">Jekyll</a> 开发.</small></p> </div> <div class="social-links"> <a class="ico-rss" href="/feed.xml" rel="me" target="_blank" title="feed"></a> <a class="ico-github" href="https://github.com/v191211/" rel="me" target="_blank" title="github"></a> <a class="ico-linkedin" href="https://www.linkedin.com/in/fighting-v/" rel="me" target="_blank" title="linkedin"></a> <a class="ico-stackoverflow" href="https://stackoverflow.com/users/4612522/adam-smith" rel="me" target="_blank" title="stackoverflow"></a> </div> </div> </div> </div> <a href="#" class="internal back-to-top">返回顶部</a> </footer> </div> <script>$(document).ready(function(){var c=50,b=500,a=960;$(window).scroll(function(){if($(window).width()>a){if($(this).scrollTop()>c){$("footer").css("top","20px");$("footer .back-to-top").fadeIn(b)}else{$("footer").css("top","auto");$("footer .back-to-top").fadeOut(b)}}});$(window).resize(function(){if($(window).width()<a){$("footer").css("top","auto");$("footer .back-to-top").fadeOut(b)}if($(window).width()>=a&&$(this).scrollTop()>c){$("footer").css("top","20px");$("footer .back-to-top").fadeIn(b)}});$("footer .back-to-top, .gotop").on("click",function(d){d.preventDefault();$("html, body").animate({scrollTop:0},b);return false});$(".show-hidden").on("click",function(){$(this).parent().next().toggleClass("hidden");$(this).toggleClass("hidden")})});</script> <script src="/assets/javascripts/jekyll-search.jquery.js"></script> <script>$(document).ready(function(){$(".search-field").simpleJekyllSearch({jsonFile:"/search.json",template:'<li><a href="{url}">{title} <span class="entry-date"><time datetime="{date}">{shortdate}</time></span></a></li>',searchResults:".search-wrapper .results",searchResultsTitle:"<h4>搜索结果</h4>",noResults:"<p>啊哈<br/><small>什么也没找到 :(</small></p>"})});(function(c,b,d){var a=function(){c(".nav-wrapper, .search-wrapper").removeAttr("style");c(".nav-form, .search-form").removeClass("active");c("body").removeClass("nav-overlay search-overlay")};c(".nav-global .btn-search").on("click",function(){c(".search-wrapper").css({display:"block"});c(".search-form").addClass("active");c(".search-form").find("input").focus();c("body").addClass("search-overlay")});c(".nav-global .btn-menu").on("click",function(){c(".nav-wrapper").css({display:"block"});c(".nav-form").addClass("active");c(".nav-form .search-field").prop("disabled",true);c("body").addClass("nav-overlay")});c(".nav-wrapper .btn-close, .search-wrapper .btn-close").on("click",function(){a()});c(document).on("keyup",function(f){if(f.keyCode===27){a()}})})(jQuery,window);</script> <script src='//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.js'></script> <script src='//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-buttons.min.js'></script> <script src="/assets/javascripts/unveil/jquery.unveil.min.js"></script> <script>window.jQuery.fancybox||document.write('<script src="/assets/javascripts/fancybox/jquery.fancybox.pack.js?v=2.1.4"><\/script>');window.jQuery.fancybox.helpers.buttons||document.write('<script src="/assets/javascripts/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"><\/script>');</script> <script>$("head").append('<link rel="stylesheet" href="/assets/javascripts/fancybox/jquery.fancybox.css?v=2.1.4" type="text/css" />');$("head").append('<link rel="stylesheet" href="/assets/javascripts/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" />');$(".post-image").fancybox({prevEffect:"none",nextEffect:"none",closeBtn:true,helpers:{title:{type:"float"}}});$(document).ready(function(){$(".post-image > img").unveil(450)});</script> </body> </html>